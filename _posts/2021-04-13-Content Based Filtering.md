---
layout: post
title:  "Content Based Filtering"
date: 2021-04-13
author: seolbluewings
categories: Statistics
---

추천 시스템이란 추천 대상자(이하 사용자)가 관심을 가질만한 컨텐츠(영화, 상품, 음악 등...)를 개인별 맞춤 형태로 추천해주는 것을 의미한다.

기본적으로 추천 시스템을 만들기 위해서는 사용자의 취향을 파악해야 한다. 추천 시스템을 활용하는 기업 입장에서는 사용자에게 구매/이용 가능성이 높은 컨텐츠를 노출 시킴으로써 매출을 증대시킬 수 있다. 유투브 같은 컨텐츠 플랫폼은 사용자가 자기들의 서비스를 더 오랫동안 이용할 수 있게 유도할 수 있다. 추천 시스템을 통해서는 충성고객을 유치할 수 있고 기업은 해당 사용자에 대한 더 많은 정보를 확보할 수 있어 사용자에게 더욱 정교한 추천을 해줄 수 있다. 정상적으로 작동한다면, 추천 시스템은 기업 입장에서 선순환 구조를 만들어낸다.

추천 시스템에는 Content Based Filtering과 Collaborative Filtering 방식이 있고 이번 포스팅에서는 Content Based Filtering에 대해 이야기 해보고자 한다.

#### 컨텐츠 기반 필터링(Content Based Filtering)

Content Based Filtering 방법은 컨텐츠의 속성을 이용, 사용자가 관심있는 컨텐츠 속성을 분석하고 사용자에게 새로운 컨텐츠를 추천해주는 방식이다. Content Based Filtering의 작동 방식은 다음과 같다.

내가 [There Will Be Blood] 라는 영화에 평점 5점을 줬다고 가정하자. 이 작품의 속성을 간단하게 정의해보면, 1. 아카데미 작품상 후보 2. PTA 감독의 작품 정도로 표현할 수 있다. 따라서 Content Based Filtering 활용 시, 추천 알고리즘은 나에게 또 다른 아카데미 작품상 후보인 [포드v페라리] 영화를 추천하거나 PTA 감독의 또 다른 작품인 [마스터], [매그놀리아] 등을 추천해줄 것이다.

![CBF](https://github.com/seolbluewings/seolbluewings.github.io/blob/master/assets/CBF.png?raw=true){:width="70%" height="70%"}{: .aligncenter}

위 이미지는 Content Based Filtering의 원리를 명쾌하게 보여줌과 동시에 Collaborative Filtering의 차이까지도 보여주는 가장 대표적인 이미지다. 사용자의 과거 컨텐츠 소비 특성을 파악하여 과거에 소비한 컨텐츠와 비슷한 컨텐츠를 추천해준다. 따라서 Content Based Filtering에서는 다른 사용자의 정보가 필요하지 않다.

다만 Content Based Filtering은 컨텐츠를 설명할 수 있는 데이터를 확보할 수 있어야 한다. 영화라는 컨텐츠를 감독, 수상, 출연배우 등으로 속성 정의를 하듯이 다른 컨텐츠를 Content Based Filtering으로 추천하고자 한다면 컨텐츠에 대한 속성 정의를 할 수 있어야 한다.

따라서 Content Based Filtering은 다음의 과정을 통해 추천이 발생한다.

1. 컨텐츠에 대한 속성(프로필) 생성
2. 사용자에 대한 속성(프로필) 정의
3. 유사도 계산을 통해서 사용자에게 추천할만한 컨텐츠를 최종적으로 예측

컨텐츠에 대한 속성을 생성할 때는 컨텐츠의 특징을 벡터화시켜서 저장하며 [TF-IDF](https://seolbluewings.github.io/statistics/2021/03/10/TFIDF.html) 같은 개념 등을 활용하여 컨텐츠 특징의 상대적 중요도를 반영하기도 한다. 앞서 소개했던 [There Will Be Blood] 작품에 대해서 [#완성도, #명작, #PTA, #아카데미] 와 같은 방식으로 속성을 정의내릴 수 있다는 것이다. 이를 벡터화 하는 과정에서 TF-IDF 개념을 이용하고, 영화감독을 지칭하는 #PTA 특징은 수없이 많은 영화 중에 TF-IDF 적용 시, 두드러지는 값을 만들어낼 것이다.

사용자에 대한 속성을 정의하는 것도 추천을 위해 필요한 과정이다. 컨텐츠 이용여부를 1,0으로 표기한 Matrix를 활용하여 우리는 사용자에 대한 속성을 정의내릴 수 있다.

다음과 같이 고객이 직접 입력하거나 시청이력을 바탕으로 한 고객-영화 Matrix가 존재한다고 하자

|고객번호|마스터|조커|킬빌|A.I.|터미널|$$\cdot\cdot\cdot$$|펄프픽션|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|101|0|1|1|0|1|$$\cdot\cdot\cdot$$|0|
|102|1|1|0|1|1|$$\cdot\cdot\cdot$$|0|
|103|0|0|1|0|0|$$\cdot\cdot\cdot$$|1|

각 영화에 대해서는 다음과 같이 속성에 대한 Matrix는 추천서비스 제공자가 입력을 해둘 것이다.

|영화명|#완성도|#복수|#철학|#무서운|#사랑|$$\cdot\cdot\cdot$$|#스필버그|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|마스터|1|0|1|0|0|$$\cdot\cdot\cdot$$|0|
|조커|1|1|1|1|0|$$\cdot\cdot\cdot$$|0|
|킬빌|1|1|0|1|0|$$\cdot\cdot\cdot$$|0|
|$$\cdot\cdot\cdot$$|$$\cdot\cdot\cdot$$|$$\cdot\cdot\cdot$$|$$\cdot\cdot\cdot$$|$$\cdot\cdot\cdot$$|$$\cdot\cdot\cdot$$|$$\cdot\cdot\cdot$$|$$\cdot\cdot\cdot$$|
|터미널|1|0|0|0|1|$$\cdot\cdot\cdot$$|1|

이 두가지 Matrix를 곱하면 아래의 Matrix와 같이 각 고객에 어떠한 속성이 매칭되는지를 알 수 있고 이를 바탕으로 고객의 속성을 정의내릴 수 있다.

|고객번호|#완성도|#복수|#철학|#무서운|#사랑|$$\cdot\cdot\cdot$$|#스필버그|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|101|4|2|1|3|3|$$\cdot\cdot\cdot$$|2|
|102|1|5|1|6|4|$$\cdot\cdot\cdot$$|1|
|103|4|3|6|1|4|$$\cdot\cdot\cdot$$|3|

그러면 이제 동일한 속성에 대해서 고객의 데이터값과 컨텐츠(영화)에 대한 데이터값을 확보할 수 있고 이를 활용해 사용자의 속성과 컨텐츠 속성에 대한 유사도를 계산할 수 있다.

#### 유사도 계산

컨텐츠와 컨텐츠의 유사도가 높다는 것은 두 컨텐츠가 비슷한 특징을 가졌다는 것을 의미하며, 사용자와 특정 컨텐츠 사이의 유사도가 높다는 것은 사용자가 해당 특정 컨텐츠를 좋아할 가능성이 높다는 것이다. 따라서 우리는 유사도 계산 결과가 높게 나온 컨텐츠를 추천해야한다.

대표적인 유사도 측정 알고리즘으로 코사인 유사도가 있다. 코사인 유사도는 두 벡터 사이의 각도를 이용해 유사도를 계산한다. 코사인의 특성 상 각도가 작을수록 값이 크기 때문에 두 벡터가 같은 방향성을 갖고 두 벡터 사이의 각이 좁으면 값이 커진다. 결국 코사인 유사도는 비교 대상이 되는 2개의 벡터가 같은 방향성을 갖는지를 체크하는 것이다.

앞서 소개한 Matrix를 한 Row씩 별개의 데이터로 따져본다면, 이는 Column 개수만큼의 차원을 가진 벡터라고 할 수 있다. 그래서 우리가 사용자와 컨텐츠를 매칭시키기로 한다면, 사용자에 해당하는 Row와 컨텐츠에 대한 Matrix를 이용하여 사용자에 알맞는 컨텐츠를 얻을 수 있다.

코사인 유사도에 대한 수식은 다음과 같다. K는 각 벡터의 크기를 의미한다.

$$
\text{Cosine Similarity} = \text{cos}\theta = \frac{\mathbf{u}_{i}\cdot\mathbf{c}_{j}}{\vert\vert \mathbf{u}_{i}\vert\vert \cdot \vert\vert \mathbf{c}_{j}\vert\vert} =\frac{\sum_{k=1}^{K}u_{ik}c_{jk}}{\sqrt{\sum_{k=1}^{K}u^{2}_{ik}}\sqrt{\sum_{k=1}^{K}c^{2}_{jk}}}
$$

코사인 유사도는 결국 벡터 간 방향성을 중요시하는 지표이기 때문에 데이터의 Scale을 무시하는 결과를 갖는다. 사용자의 속성을 정의하는 벡터가 [1,1,1] 값을 가지고 컨텐츠1의 속성이 [2,2,2] 컨텐츠2의 속성이 [7,7,7] 값을 갖는다고 하면 코사인 유사도 결과는 컨텐츠 1,2에 대해서 모두 1이 나온다. 따라서 코사인 유사도는 벡터가 다양한 차원으로 존재할 때, 유사도를 잘 반영할 수 있지만 Scale을 무시함으로써 발생하는 치명적인 단점이 있다.

코사인 유사도의 단점을 보완하는 방법으로는 조정된 코사인 유사도(Adjusted Cosine Similarity) 방법이 있다. 전체적인 방법은 동일하다. 컨텐츠 N개에 대한 컨텐츠 속성 벡터가 평균값으로 [3,1,2] 이라면, 컨텐츠1은 평균값을 뺀 [-2,0,-1] 값을 갖는 것으로 컨텐츠2는 [4,6,5]값을 갖는 것으로 계산을 수행할 수 있다.






#### 참조 문헌
1. [추천시스템 : 컨텐츠 기반 필터링](https://skyeong.net/265) <br>
2. [코사인 유사도](https://wikidocs.net/24603)
